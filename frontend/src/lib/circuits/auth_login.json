{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":13217013542956568892,"abi":{"parameters":[{"name":"private_key","type":{"kind":"field"},"visibility":"private"},{"name":"wallet_address","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5ZzNbhXJEoTfxWsWXdVZ1d28ytVoZMCMLFk24udKV+i++xjkcwbZEKkz5CIyY2dDgypxZGRwOuv7evXu5s2Xv/68vX//8Onq9X++Xt09vL3+fPtw//jd16vl+y99+nB9/+27T5+vP36+et1s3V9d3dy/+/bl3P//6ur97d3N1etvX754eO7r07Pbspwf3dpPHu3reHq0b/2fR9efPbr0fnp2We2fh/tPHrZxHE8P21zmjw//8eqqlShxtnkuse/PSuz1S1xrCHU7neHxy+clWv1eHPWFOusLdasv1L2+UI/6Qm1F4g2ssUa+wTXWCDg4ptZIONBymglotUbGwVqtEXKwVmlTTju207N9OX5Lq7QxJ7BG2pwTV2OnzTmX1Yg8p9PmnItqxJ/j0OacQK3S5pxArZqAVmlzzrqdjt1tac+PTRtd8LFp0wg+Nm3AwMemzQw22vnYc+L+na2dHn78cjs/3Mf3D9RpM8NlNY7jXON8USNtZhjj7MNj78/kt7LGgHVp9vTsuqzH82PTTvbArjGBGmkne6Az0MYA7Ay0MSBQfrSZIbDGIgEDtZjRBgzYYsaaGfDwNdqPDuK6xgQChpmAM9AGDOwMtJkhUH4CAcOKBAzYYrQBA7bYYM0MePgO2s8Z4rpmCASMUSRgIGcYltMZinwoAeUnEDBGkYABW4w2YOAWY80MePjOIi8yUNdMgYAxiwQM5AyTNmBAZ5gmID+BgDGLBAzYYrQBA7cYa2Zwhq/ApsQmEDC2IgEDOcNGGzCgM2wCbz02E6hRYK1iy7lWsbFmBjx8N4FNiU0gYOwCq5h7zlXMXeCtxy4QMHYTaLGcaxU7a2bAw3cX2JTYBQLGLrCKeeRcxTwE3nocAgHjEFirOCxni7FmBjx8D4FNiUMgYBwCq5hHzlXMtgi89miLQMRoi8BmRVtyrla0xVJO4LYI7Eu0RSBntEVgJbMtOXcy2yLw/qPxcjojixRYsWi8pE7cZrT0TWcK8xI1IztHIWrwMjUj7SHncmbjBWVGKlAhavCiMgPbjJeViduMln/pTGFepmVk55hCkQJLmo2XgenYg8AbkcaLzIwsUmDpovESNnGb0VIznSlMi82M7BwFyGarQtnE9pBzXbPxojMjFagQNaqQNnGbJV2/oMVnOlOYlp8Z2TkKtM1WBbcJ7YGXt+nYg8I7EQXiZquC3MRtlnT9gpaj6UxhWpBmZOcoYDdbFe4mtAde8Ca2B16YZqQCFaJGFfYmbrOk6xe0QE1vCitsVCjwN1sVACe0B14CJ7YHXqpmpAJNoUiF9QteCqfTZjkpWY0WrRnaOQpRowqJE9oDL4oT2wMvXjNSgQpRowqNE7dZ0vULWsSmM4VpGZuhnaMQNaogOaE98DI5sT3wcjYDFahA5WxVsJy4zSxpm+XkZjVa2GZo5yhEjSpsTmwPSZc3eYGbgQpUwHO2KnxO2Ga8gE6nzSznFKalboZ2jkLUqALpxPaQdHmTl7wZp8CugOnsVTCdqM06L6YTtlmnJW/iKdwXU+gcgajRq2A6sT3kXN7svOTNSAUqRI0qmE7YZryYTtxmtORNZwrTkjdDO8cUihRY3uy8mE7HHgTeiXQFTGevgumEbcaL6cRtRkvedKYwLXkzsnMUMJ29CqYT20PO5c3OS96MVKBC1KiC6cRtlnP9otOSN50pTEvejOwcBUxnr4LphPbAi+l07EHhnYgCprNXwXTiNsu5ftFpyZvOFKYlb0Z2jgKms1fBdEJ74MV0YnvgJW9GKlAhalTBdOI2S7p+QUve9KawwkaFAqazV8F0QnvgxXRie+Alb0Yq0BSKVFi/4MV0Om2Wk53VacmboZ2jEDWqYDqhPfBiOrE98JI3IxWoEDWqYDpxmyVdv6AlbzpTmJa8Gdo5ClGjCqYT2gMvphPbAy95M1CBCpjOXgXTidvMkrZZTnZWpyVvhnaOQtSogunE9pB0eZOWvLm2dZ7sodmOfzg2ttMZHr/cXxRJe0/ksiKPkwJtLvNFkbRXUi8q8rG5zkX2lz9JWvpFpFxNQa60uSRSrrQfgUTKlfZtS2SRtIsdkUXS7pAGGg8tLTTSeGhpoZFypaWFhsq1RuJx5GoKcq2ReJwiFRIPLYc01HhqJB7HeIokHiTXlRZaGijXlRZaGijXlRZauq7j9Oy6/vDp6L+SK23iiSzSFIqkTTyXFYmNhzbxXFSkYzy0iSdSrrSJJ1KutIknUK6/YKfOeS5yswMX2Zbze7O2bIbLtPM/+VgnLrMvvZ/+SZbVfkuwv6CnJiwTSvYXsNV8ZTqiXTV+mqbx0xwaZU4N0W4aP81do8xDIh50jRTUy6QgXGaVFOSUqZGCukYK6lVSkCNajRTUNVJQr5KCHNGWSUFQtGuVFIRFu2qkoLVMCsKirZKCHNGahmg1UtBaJgXhMqukIKdMjRS0aqQg00hBppGCTCMFmUYKMo0UZGVSEBZtlRTkiFYjBVmZFIRFWyUFYdEO4hTUjvM9/b4cvyXaQZyCIsskTkGRZRKnoMgyTaNM4hR0WZlwoAziFHRRmc5AIU5BkaIlTkGRoiVOQYGinRopaJZJQVC0s0oKckSrkYJmmRSERVslBTmiJU5B63Y6ebelvTg5cbBxTk6cVZyTE8cPfPKNOFE4JycOCc7Jiee+c3LiUe6cnHg6xxFb1414OscxW9eNeDpDauu68U5njHVeN97p7J2cdzo7J9+Jp3Oga+3EozyyTOK5H2jOO3FIwOa8a4SEvUxIwGUSh4TIdiP+/77TbmkTxZ42URy8icI7uUZIOMqEBFwmcUgINOeDOFFgcz40QsJRJiTgMolDQmS7Eb9BcNota6KwJWuisIU3UXgnlwgJtpQJCbhMUzBnW4gTBTRnWyRCgi1lQgIukzgkRLYb8U4CbjdiBqwzl4mxrt7JeROFd3KNkMAMX40sU2KBwZjhq445a4QEZp5qZJnEISGw3Zh5qrjdiBGpzlwmpp56J+dNFN7JTcK1mNmkkWVKLDAYM5vUMWeNkMCMGw0skxk3GthuzLhR3G7EBFFnLhNDQb2TW9qTa4QEZnRnZJkSCwzGjO50zFkjJDDTOCPLLLNsCduNmcaJ240YsOnMZWJmpndy3kThnVwjJDCTLSPL1FhgYCZbYnNmhlUG6pAZVhlZpsS1TWOGVTrtZlnnMjFS0js5b6LwTq4REpjBj5FlaiwwMIMfsTkzsxwDdcjMcowsU+LapjGzHJ12S5soiImL3smzMp2MmbgY6Voa7yaYWY6B5swMfsTmzAx+jNShxo2MOkhJ3G5pr20SUyKduZyWEmlpKZFGTImMdC0NpKTVQUpCc2ZGSmJzZqZERurQNMrUuLbJjJR02i1tokhLibS0lEgjpkRGupYGUtLqICWhOTMjJbE5M1MiI3WocSOjDlISt1vaa5vElEhvLmdNFCMtJXIQUyIDXWtoICVHHaQkMuexWFJzHsyUyEgdStzIGHWQkrjdsl7bHMSUSGcup6VEjrSUyEFMiYx0LQ2k5KiDlITmzIyUxObMTImM1KHEjYxRBymJ2y3rtc1BTIl05nJaSuRIS4kcxJTISNfSQEqOOkhJaM7MSEnHnDVCggZSctRBSsJ2Y0ZK4nYjpkQ6czktJXKkpUQOYkpkpGtpICVHHaQkNuesCwyDmRIZqUOJGxmjDlISthszUhK3GzEl0pnLaSmRIy0lchBTIkNdS+PdRB2kJDbntAsMzJTIQB1qICVHHaQkbDdmpCRuN2JKpDOX01IiR1pK5CCmRIa6lsa7iTpISWzOaRcYmCmRgTrUQEqOOkhJ2G7MSEmn3SzrXE5LiRxpKZGDmBIZ6loa7ybqICWhOTMjJbE5M1MiA3WogZQcdZCSuN0sbbulTRRpKZEjLSVyEFMiQ11L491EHaQkNGdmpCQ2Z2ZKZKQONW5k1EFK4nZLe22TmBLpzOW0lMiRlhI5iCmRka6lgZQcdZCS0JyZkZLYnJkpkZE6NI0yNa5tMiMlnXZLmyjSUiJHWkrkJKZEBrrW1EBKzjpISWTOkxkpCc15LqahQ4kbGbMOUhK3W9Zrm5OYEunN5bSJIi0lchJTIiNdSwMpOesgJaE5MyMlsTkzUyIjdShxI2PWQUridst6bXMSUyKduZyWEjnTUiInMSUy0rU0kJKzDlISmjMzUhKbMzMlMlKHEjcyZh2kJG63rNc2JzEl0pnLaSmRMy0lchJTIiNdSwMpOesgJaE5MyMlHXPWCAkaSMlZBykJ240ZKYnbjZgS6czltJTImZYSOYkpkZGupYGUnHWQktic0y4wMFMiI3UocSNj1kFKwnZjRkridiOmRDpzOS0lcqalRE5iSmSoa2m8m6iDlMTmnHaBgZkSGahDDaTkrIOUhO3GjJTE7UZMiXTmclpK5ExLiZzElMhQ19J4N1EHKYnNOe0CAzMlMlCHGkjJWQcpCduNGSnptJtlnctpKZEzLSVyElMiQ11L491EHaQkNGdmpCQ2Z2JK5NrWeTKKZjv+AdnY1qeHH7/cX5RJ/G7isjLPf7HNZb4ok/hjh4vKfGyyc5n95U/TNERLHD8iRUucVSJFS4yWihQtMTUiUrTEF0IDRUuMwYwULTEGM1K0xBjMUNFWSUGOaE2jzDIpCJdZJQU5ZWqkIGYaZ+RAkUhBGzHnM1C0GzHnM1C0GzHnM1S0EiloW0xDtFVSkCNaiRS0EUNBQ0VbJQU5oq2SgrBomdmkkWVKvBHbiEGmoWVqpCBikGnkQCGmnkYOFGLqaahoNVIQMfU0VLQaKYiZpxooWmb4aqBoiUmtoaItk4KwaE1DtMQpaB3jVOb6w57kvxItcQqKLJM4BUWWSZyCIsskTkGBZTIzYC8rEw4UZmDsRWXigcJMl40ULXEKihStaYhWIwURo2hDRVslBTmi1UhBxNzaSNESc2sjRfsLyO2xnu7PtWPaj2X+8fjNm4+3d3e3f/159/D2+vPtw/2nxz/6+Mv/vf54e/3m7ubp2/df7t/+8Luf//fh9DunP//h48Pbm3dfPt58+5u+/97jX/83","file_map":{"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"68":{"source":"// contracts/circuits/auth_login/src/main.nr\n//\n// Authentication Circuit for zkCredentials\n// =========================================\n//\n// This circuit proves that a user knows the private key corresponding\n// to a public commitment WITHOUT revealing the private key or wallet address.\n//\n// Use Case: Privacy-preserving login for all user types\n// (admin, university, student, employer)\n//\n// Inputs:\n//   - privateKey (private): User's secret authentication key\n//   - walletAddress (private): User's blockchain wallet address\n//   - salt (private): Random salt for commitment uniqueness\n//   - commitment (public): Public commitment to verify against\n//\n// Output:\n//   - Proof that the user knows the private key and wallet for the commitment\n//\n// Security:\n//   - Private inputs are never revealed\n//   - Only the validity of the commitment is proven\n//   - Poseidon hash used for ZK-friendly hashing (BN254 curve compatible)\n\nuse dep::poseidon::poseidon::bn254::hash_1 as poseidon_hash_1;\nuse dep::poseidon::poseidon::bn254::hash_3 as poseidon_hash_3;\n\nfn main(\n    // Private inputs (kept secret by prover)\n    private_key: Field,\n    wallet_address: Field,\n    salt: Field,\n    \n    // Public inputs (visible to verifier)\n    commitment: pub Field\n) {\n    // Step 1: Derive public key from private key using Poseidon hash\n    // This is a one-way function - knowing public key doesn't reveal private key\n    let public_key = poseidon_hash_1([private_key]);\n    \n    // Step 2: Compute commitment = hash(publicKey, walletAddress, salt)\n    // The salt prevents rainbow table attacks and allows multiple commitments per wallet\n    let computed_commitment = poseidon_hash_3([\n        public_key,\n        wallet_address,\n        salt\n    ]);\n    \n    // Step 3: Constrain that computed commitment matches the public commitment\n    // This proves the user knows the private key and wallet without revealing them\n    assert(computed_commitment == commitment);\n}\n\n#[test]\nfn test_auth_login_valid() {\n    // Test case: Valid authentication proof\n    let private_key: Field = 12345678901234567890;\n    let wallet_address: Field = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1;\n    let salt: Field = 98765432109876543210;\n    \n    // Compute expected commitment using Poseidon\n    let public_key = poseidon_hash_1([private_key]);\n    let expected_commitment = poseidon_hash_3([\n        public_key,\n        wallet_address,\n        salt\n    ]);\n    \n    // This should pass\n    main(private_key, wallet_address, salt, expected_commitment);\n}\n\n#[test]\nfn test_auth_login_different_commitments() {\n    // Test case: Different private keys produce different commitments\n    let private_key1: Field = 12345678901234567890;\n    let private_key2: Field = 98765432109876543210;\n    let wallet_address: Field = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1;\n    let salt: Field = 11111111111111111111;\n    \n    // Compute commitments for both keys using Poseidon\n    let public_key1 = poseidon_hash_1([private_key1]);\n    let commitment1: Field = poseidon_hash_3([\n        public_key1,\n        wallet_address,\n        salt\n    ]);\n    \n    let public_key2 = poseidon_hash_1([private_key2]);\n    let commitment2: Field = poseidon_hash_3([\n        public_key2,\n        wallet_address,\n        salt\n    ]);\n    \n    // Verify they produce different commitments\n    assert(commitment1 != commitment2);\n}\n\n// Test with specific values to compare with JavaScript poseidon-lite\n#[test]\nfn test_poseidon_compatibility() {\n    // Use simple test values\n    let private_key: Field = 12345678901234567890;\n    let wallet_address: Field = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1;\n    let salt: Field = 98765432109876543210;\n    \n    // Compute public key\n    let public_key = poseidon_hash_1([private_key]);\n    \n    // Compute commitment\n    let computed_commitment = poseidon_hash_3([\n        public_key,\n        wallet_address,\n        salt\n    ]);\n    \n    // Print for comparison with JavaScript\n    std::println(public_key);\n    std::println(computed_commitment);\n    \n    // This test should pass - it just computes the values\n    assert(public_key != 0);\n    assert(computed_commitment != 0);\n}\n","path":"/home/vmanolas/src/zkp/project/zksync-zzlogin-dapp-Sep-2025-d/contracts/circuits/auth_login/src/main.nr"},"71":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon/bn254.nr"},"72":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon/mod.nr"},"73":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidonv0.1.1/src/poseidon/bn254/perm.nr"}},"names":["main"],"brillig_names":[]}