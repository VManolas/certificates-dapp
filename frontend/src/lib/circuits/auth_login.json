{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"9318039130314779809","abi":{"parameters":[{"name":"private_key","type":{"kind":"field"},"visibility":"private"},{"name":"wallet_address","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"// contracts/circuits/auth_login/src/main.nr\n//\n// Authentication Circuit for zkCredentials\n// =========================================\n//\n// This circuit proves that a user knows the private key corresponding\n// to a public commitment WITHOUT revealing the private key or wallet address.\n//\n// Use Case: Privacy-preserving login for all user types\n// (admin, university, student, employer)\n//\n// Inputs:\n//   - privateKey (private): User's secret authentication key\n//   - walletAddress (private): User's blockchain wallet address\n//   - salt (private): Random salt for commitment uniqueness\n//   - commitment (public): Public commitment to verify against\n//\n// Output:\n//   - Proof that the user knows the private key and wallet for the commitment\n//\n// Security:\n//   - Private inputs are never revealed\n//   - Only the validity of the commitment is proven\n//   - Poseidon hash used for ZK-friendly hashing (BN254 curve compatible)\n\nuse dep::poseidon::poseidon::bn254::hash_1 as poseidon_hash_1;\nuse dep::poseidon::poseidon::bn254::hash_3 as poseidon_hash_3;\n\nfn main(\n    // Private inputs (kept secret by prover)\n    private_key: Field,\n    wallet_address: Field,\n    salt: Field,\n    \n    // Public inputs (visible to verifier)\n    commitment: pub Field\n) {\n    // Step 1: Derive public key from private key using Poseidon hash\n    // This is a one-way function - knowing public key doesn't reveal private key\n    let public_key = poseidon_hash_1([private_key]);\n    \n    // Step 2: Compute commitment = hash(publicKey, walletAddress, salt)\n    // The salt prevents rainbow table attacks and allows multiple commitments per wallet\n    let computed_commitment = poseidon_hash_3([\n        public_key,\n        wallet_address,\n        salt\n    ]);\n    \n    // Step 3: Constrain that computed commitment matches the public commitment\n    // This proves the user knows the private key and wallet without revealing them\n    assert(computed_commitment == commitment);\n}\n\n#[test]\nfn test_auth_login_valid() {\n    // Test case: Valid authentication proof\n    let private_key: Field = 12345678901234567890;\n    let wallet_address: Field = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1;\n    let salt: Field = 98765432109876543210;\n    \n    // Compute expected commitment using Poseidon\n    let public_key = poseidon_hash_1([private_key]);\n    let expected_commitment = poseidon_hash_3([\n        public_key,\n        wallet_address,\n        salt\n    ]);\n    \n    // This should pass\n    main(private_key, wallet_address, salt, expected_commitment);\n}\n\n#[test]\nfn test_auth_login_different_commitments() {\n    // Test case: Different private keys produce different commitments\n    let private_key1: Field = 12345678901234567890;\n    let private_key2: Field = 98765432109876543210;\n    let wallet_address: Field = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1;\n    let salt: Field = 11111111111111111111;\n    \n    // Compute commitments for both keys using Poseidon\n    let public_key1 = poseidon_hash_1([private_key1]);\n    let commitment1: Field = poseidon_hash_3([\n        public_key1,\n        wallet_address,\n        salt\n    ]);\n    \n    let public_key2 = poseidon_hash_1([private_key2]);\n    let commitment2: Field = poseidon_hash_3([\n        public_key2,\n        wallet_address,\n        salt\n    ]);\n    \n    // Verify they produce different commitments\n    assert(commitment1 != commitment2);\n}\n","path":"/home/vmanolas/src/zkp/project/zksync-zzlogin-dapp-Sep-2025-d/contracts/circuits/auth_login/src/main.nr"},"56":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"57":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"58":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/home/vmanolas/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}