// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/**
 * @title IUltraPlonkVerifier
 * @notice Interface for the auto-generated UltraPlonk verifier
 * @dev The actual verifier contract will be generated by Barretenberg
 */
interface IUltraPlonkVerifier {
    function verify(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool);
}

/**
 * @title UltraPlonkAuthVerifierAdapter
 * @notice Adapter to make UltraPlonk verifier compatible with IAuthVerifier interface
 * @dev Wraps the auto-generated UltraPlonk verifier contract
 * 
 * This adapter serves multiple purposes:
 * 1. Matches the IAuthVerifier interface expected by ZKAuthRegistry
 * 2. Adds events for monitoring verification attempts
 * 3. Provides metadata about the verifier (production status, circuit name)
 * 4. Allows easy swapping of verifier implementation
 * 
 * Security:
 * - The actual cryptographic verification is done by the UltraPlonk verifier
 * - This contract only wraps and monitors the verifier
 * - Immutable verifier address prevents malicious replacement
 */
contract UltraPlonkAuthVerifierAdapter {
    
    /// @notice The UltraPlonk verifier contract (immutable for security)
    IUltraPlonkVerifier public immutable verifier;
    
    /// @notice Circuit name for identification
    string public constant CIRCUIT_NAME = "auth_login_ultraplonk";
    
    /// @notice Contract version
    string public constant VERSION = "1.0.0";
    
    // Events
    
    /// @notice Emitted when a verification is attempted
    /// @param success Whether the proof was valid
    /// @param publicInputHash Hash of the public inputs
    /// @param proofLength Length of the proof in bytes
    event VerificationAttempted(
        bool indexed success,
        bytes32 indexed publicInputHash,
        uint256 proofLength
    );
    
    /// @notice Emitted when a verification fails with details
    /// @param reason Reason for failure
    /// @param publicInputHash Hash of public inputs
    event VerificationFailed(
        string reason,
        bytes32 indexed publicInputHash
    );
    
    // Errors
    
    error InvalidVerifierAddress();
    error EmptyProof();
    error EmptyPublicInputs();
    error ProofVerificationFailed();
    
    /**
     * @notice Constructor
     * @param _verifier Address of the UltraPlonk verifier contract
     */
    constructor(address _verifier) {
        if (_verifier == address(0)) revert InvalidVerifierAddress();
        verifier = IUltraPlonkVerifier(_verifier);
    }
    
    /**
     * @notice Verify a zero-knowledge proof (IAuthVerifier interface)
     * @param proof The proof bytes generated by Noir
     * @param publicInputs The public inputs (commitment)
     * @return valid True if proof is cryptographically valid
     * 
     * @dev This function performs real cryptographic verification using UltraPlonk
     * 
     * Gas Cost: ~250-350K gas on L1, ~50-70K gas on zkSync Era L2
     * 
     * Security:
     * - Validates input format before calling verifier
     * - Emits events for monitoring and debugging
     * - Uses try-catch to handle verifier failures gracefully
     */
    function verify(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external returns (bool valid) {
        // Input validation
        if (proof.length == 0) revert EmptyProof();
        if (publicInputs.length == 0) revert EmptyPublicInputs();
        
        // Compute hash of public inputs for logging
        bytes32 publicInputHash = keccak256(abi.encodePacked(publicInputs));
        
        // Call the UltraPlonk verifier
        // This performs the actual cryptographic verification:
        // 1. Parses proof bytes into curve points
        // 2. Loads verification key
        // 3. Computes challenges via Fiat-Shamir
        // 4. Verifies pairing equation
        try verifier.verify(proof, publicInputs) returns (bool result) {
            valid = result;
            
            // Emit event
            emit VerificationAttempted(valid, publicInputHash, proof.length);
            
            if (!valid) {
                emit VerificationFailed("Proof verification failed", publicInputHash);
            }
            
            return valid;
        } catch Error(string memory reason) {
            // Verifier reverted with a reason
            emit VerificationFailed(reason, publicInputHash);
            emit VerificationAttempted(false, publicInputHash, proof.length);
            return false;
        } catch (bytes memory) {
            // Verifier reverted without a reason
            emit VerificationFailed("Verifier reverted", publicInputHash);
            emit VerificationAttempted(false, publicInputHash, proof.length);
            return false;
        }
    }
    
    /**
     * @notice Check if this is a production-ready verifier
     * @return true (this is the real cryptographic verifier)
     * 
     * @dev This distinguishes from the development MockAuthVerifier
     */
    function isProductionReady() external pure returns (bool) {
        return true;
    }
    
    /**
     * @notice Get the circuit name
     * @return The name of the circuit this verifier is for
     */
    function getCircuitName() external pure returns (string memory) {
        return CIRCUIT_NAME;
    }
    
    /**
     * @notice Get the contract version
     * @return The version of this adapter contract
     */
    function getVersion() external pure returns (string memory) {
        return VERSION;
    }
    
    /**
     * @notice Get the underlying verifier address
     * @return The address of the UltraPlonk verifier contract
     */
    function getVerifierAddress() external view returns (address) {
        return address(verifier);
    }
    
    /**
     * @notice Get expected proof format (for documentation)
     * @return Description of the proof format
     */
    function getProofFormat() external pure returns (string memory) {
        return "UltraPlonk proof format (Barretenberg generated)";
    }
}
